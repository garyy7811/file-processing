package org.pubanatomy.batchpartition;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

import javax.sql.DataSource;
import java.util.List;
import java.util.Map;

/**
 * User: flashflexpro@gmail.com
 * Date: 4/23/2015
 * Time: 4:40 PM
 * <context:annotation-config/>
 * <tx:annotation-driven transaction-manager="transactionManager"/>
 */
@Transactional( isolation = Isolation.SERIALIZABLE, propagation = Propagation.REQUIRES_NEW )
public class RangePartitionServiceImpl implements RangePartitionService{

    private static final Logger logger = LogManager.getLogger( RangePartitionServiceImpl.class );


    public RangePartitionServiceImpl( RangePartitionService.Config config, DataSource dataSource, boolean recreateTable,
                                      boolean deleteWorkingRanges ){
        this.config = config;

        this.dataSource = dataSource;
        this.jdbcTemplate = new JdbcTemplate( dataSource );
        initializeTable( recreateTable, deleteWorkingRanges );
    }

    private Config config;

    public Config getConfig(){
        return config;
    }

    private DataSource dataSource;

    public DataSource getDataSource(){
        return dataSource;
    }


    private JdbcTemplate jdbcTemplate;

    public JdbcTemplate getJdbcTemplate(){
        return jdbcTemplate;
    }

    private synchronized void initializeTable( boolean recreateTable, boolean deleteWorkingRanges ){

        boolean tableExist = false;
        try{
            long tmp = jdbcTemplate.queryForObject( "SELECT count( * ) FROM " + config.getTableName(), Long.class );
            logger.info( "Table {} exists with {} records", config.getTableName(), tmp );
            tableExist = true;
        }
        catch( DataAccessException e ){
            logger.info( "Table {} NOT exists ", config.getTableName() );
        }

        if( tableExist && recreateTable ){
            final String dropTable = "DROP TABLE IF EXISTS " + config.getTableName() + ";";
            jdbcTemplate.execute( dropTable );
            tableExist = false;
        }

        if( ! tableExist ){
            final String createTable = "CREATE TABLE " + config.getTableName() + "(\n" +
                    "  id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1) PRIMARY KEY ,\n" +
                    "  range_from BIGINT NOT NULL,\n" + "  range_to   BIGINT  NOT NULL,\n" +
                    "  status    VARCHAR(64) NOT NULL,\n" + "  createdTime     BIGINT NOT NULL,\n" +
                    "  lastUpdate     BIGINT NOT NULL,\n" + "  lastOwner     VARCHAR(256),\n" +
                    "  COMMENT   LONGVARCHAR\n  );";
            jdbcTemplate.execute( createTable );
            logger.info( "table created " );
        }
        else if( deleteWorkingRanges ){
            //clean the working records
            int c = jdbcTemplate.update( "DELETE FROM " + config.getTableName() + " WHERE status=?", Config.STATUS_WORKING );
            logger.info( "{}-DELETing {} working records ...", config.getTableName(), c );
        }
    }


    public synchronized Long[] allocateRange( Long rootTo ){
        return allocateRange( rootTo, null, false, null );
    }

    public synchronized Long[] allocateRange( Long rootTo, String comment ){
        return allocateRange( rootTo, null, false, comment );
    }

    public synchronized Long[] allocateRange( Long rootTo, Long[] range, boolean rangeOnForce, String comment ){


        logger.debug( "requested rootTo={} for table=", rootTo, config.getTableName());

        Long rootF = config.getRootFrom();

        if( rootTo != null ){

            // validate the request: incoming rootTo must be > rootF and >= config.rootTo

            if (rootF != null && rootF >= rootTo) {
                logger.warn( "invalid rootTo:{} smaller than rootFrom:{}", rootTo, rootF);
                return new Long[]{};
            }

            // only validate against config.rootTo if it has been set previously
            if( config.getRootTo() != Long.MAX_VALUE && config.getRootTo() > rootTo ){
                logger.warn( " invalidate rootTo:{} smaller than current:{}", rootTo, config.getRootTo() );
                return new Long[]{};
            }

            // rootTo is valid - set as the new config.rootTo value

            config.setRootTo( rootTo );
        }
        Assert.isTrue( range == null || range[ 0 ] < range[ 1 ] );

        if( config.getMaxWorkingInParallel() > 0 &&
                countByStatus( Config.STATUS_WORKING ) >= config.getMaxWorkingInParallel() ){
            return new Long[]{ config.getMaxWorkingInParallel().longValue() };
        }

        String where = "";
        Long rootT = config.getRootTo();

        if( range != null ){
            rootF = range[ 0 ];
            rootT = range[ 1 ];
            if( rangeOnForce ){
                int tmpNumDel = jdbcTemplate
                        .update( " DELETE FROM " + config.getTableName() + " WHERE range_from>=? AND range_to<=?",
                                range[ 0 ], range[ 1 ] );
                int tmpNumF = jdbcTemplate
                        .update( " UPDATE " + config.getTableName() + " SET range_to=? WHERE range_to>? AND range_to<?",
                                range[ 0 ], range[ 0 ], range[ 1 ] );
                int tmpNumT = jdbcTemplate.update(
                        " UPDATE " + config.getTableName() + " SET range_from=? WHERE range_from>? AND range_from<?",
                        range[ 1 ], range[ 0 ], range[ 1 ] );
                logger.info( " rangeOnForce {} deleted, {}left, {}right", tmpNumDel, tmpNumF, tmpNumT );
            }
            where = " WHERE range_from >= " + range[ 0 ] + " AND range_to <=" + range[ 1 ];
        }

        logger.info( "locating next range for table:{}, root[{}-{}]", config.getTableName(), rootF, rootT );

        String tmpSql = "SELECT range_from, range_to FROM " + config.getTableName() + where + " ORDER BY range_to";
        List<Map<String, Object>> allRecords = jdbcTemplate.queryForList( tmpSql );

        Long rtFrom = null;
        Long rtTo = null;
        int size = allRecords.size();

        logger.info( "allRecords.size():{}:", allRecords.size() );

        if( size > 0 ){
            Map<String, Object> first = allRecords.get( 0 );
            Long firstRangeFrom = ( Long )first.get( "range_from" );
            if( firstRangeFrom.equals( rootF ) ){
                for( int i = 0; i < size; i++ ){
                    Map<String, Object> record = allRecords.get( i );
                    Long tmpTo = ( Long )record.get( "range_to" );

                    Long tmpNextFrom = null;

                    if( i < size - 1 ){
                        Map<String, Object> next = allRecords.get( i + 1 );
                        tmpNextFrom = ( Long )next.get( "range_from" );
                        if( tmpTo < tmpNextFrom ){
                            rtFrom = tmpTo;
                            rtTo = Math.min( tmpTo + config.getStep(), tmpNextFrom );
                            break;
                        }
                    }
                    else{
                        rtFrom = tmpTo;
                    }
                }
            }
            else{
                rtTo = Math.min( rootF + config.getStep(), firstRangeFrom );
            }
        }

        if( rtFrom == null ){
            rtFrom = rootF;
        }

        if( rtTo == null ){
            rtTo = Math.min( rtFrom + config.getStep(), rootT );
        }

        if( rtFrom > rtTo ){
            logger.fatal( "rtFrom > rtTo: {}>{}", rtFrom, rtTo );
            throw new Error( "rtFrom > rtTo" );
        }

        if( rtTo.equals( rtFrom ) ){
            logger.info( "rtTo.equals( rtFrom ):{}", rtTo );
            return new Long[]{};
        }

        jdbcTemplate.update( "INSERT INTO " + config.getTableName() +
                        " ( range_from, range_to, status, comment, createdTime, lastUpdate, lastOwner ) VALUES (?,?,?,?,?,?,?)",
                rtFrom, rtTo, Config.STATUS_WORKING, comment, System.currentTimeMillis(), System.currentTimeMillis(),
                Thread.currentThread().getName() );

        logger.info( "returning next range for {} - from:{} to {}", config.getTableName(), rtFrom, rtTo );

        return new Long[]{ rtFrom, rtTo };
    }

    public synchronized int updateRange( Long rangeFrom, Long rangeTo, String status, String comment ){
        if( rangeFrom >= rangeTo ){
            logger.error( "range illegal[{}-{}]", rangeFrom, rangeTo );
            return - 1;
        }
        logger.info( "{}- [ from:{}, to:{}, status:{}, comment:{} ]", config.getTableName(), rangeFrom, rangeTo, status,
                comment );
        return jdbcTemplate.update( " UPDATE " + config.getTableName() +
                        " SET status=?, comment=?, lastUpdate=?, lastOwner=?  WHERE range_from=? and range_to=?", status,
                comment, System.currentTimeMillis(), Thread.currentThread().getName(), rangeFrom, rangeTo );
    }


    public synchronized int doneRange( Long rangeFrom, Long rangeTo, String comment ){

        logger.info( "{}- [ rangeFrom:{}, rangeTo:{} ]", config.getTableName(), rangeFrom, rangeTo );

        Long tmpFrom = rangeFrom;
        Long tmpTo = rangeTo;
        Long tmpCreatedTime = null;

        final List<Map<String, Object>> list = jdbcTemplate
                .queryForList( "SELECT * FROM " + config.getTableName() + " WHERE range_from=? AND range_to=?",
                        rangeFrom, rangeTo );
        Assert.isTrue( list.size() == 1 );

        Map theOne = list.get( 0 );

        tmpCreatedTime = ( Long )theOne.get( "createdTime" );
        String theOneComment = makeRecordStr( theOne );

        List<Map<String, Object>> prev = jdbcTemplate
                .queryForList( "SELECT * FROM " + config.getTableName() + " WHERE range_to=? AND status=?", rangeFrom,
                        Config.STATUS_DONE );
        Assert.isTrue( prev.size() <= 1 );

        if( prev.size() == 1 ){
            tmpCreatedTime = ( Long )prev.get( 0 ).get( "createdTime" );
            tmpFrom = ( Long )prev.get( 0 ).get( "range_from" );
            theOneComment = makeRecordStr( prev.get( 0 ) ) + theOneComment;
        }

        List<Map<String, Object>> next = jdbcTemplate
                .queryForList( "SELECT * FROM " + config.getTableName() + " WHERE range_from=? AND status=?", rangeTo,
                        Config.STATUS_DONE );
        Assert.isTrue( next.size() <= 1 );
        if( next.size() == 1 ){
            tmpTo = ( Long )next.get( 0 ).get( "range_to" );
            theOneComment = theOneComment + makeRecordStr( next.get( 0 ) );
        }

        int tmp = jdbcTemplate
                .update( "DELETE FROM " + config.getTableName() + " WHERE ( range_from=? OR range_to=? ) AND status=?",
                        rangeTo, rangeFrom, Config.STATUS_DONE );

        Assert.isTrue( tmp == prev.size() + next.size() );

        logger.info( "{} - [ rangeFrom:{}, rangeTo:{}, comment: {}, deleted:{} ]", config.getTableName(), rangeFrom,
                rangeTo, comment, tmp );

        return jdbcTemplate.update( " UPDATE " + config.getTableName() +
                        " SET range_from=?, range_to=?, status=?, comment=?, createdTime=?, lastUpdate=?  WHERE id=?", tmpFrom,
                tmpTo, Config.STATUS_DONE, theOneComment + " merged" + tmp, tmpCreatedTime, System.currentTimeMillis(),
                theOne.get( "id" ) );
    }

    private String makeRecordStr( Map theOne ){
        final Object tmp = theOne.get( "comment" );
        final String tmpCmt = ( tmp == null ? "" : tmp.toString() );
        final String tOneFr = theOne.get( "range_from" ).toString();
        final String tOneTo = theOne.get( "range_to" ).toString();

        String rt = "[" + tOneFr + "-" + tOneTo + "](" + tmpCmt + ")";
        if( rt.length() > 20482 ){
            rt = rt.substring( rt.length() - 20482 );
        }
        return rt;
    }


    public synchronized int errorRange( Long rangeFrom, Long rangeTo, Long failedOn, String comment ){
        if( failedOn == null ){
            return updateRange( rangeFrom, rangeTo, Config.STATUS_ERROR, comment );
        }
        Assert.isTrue( failedOn >= rangeFrom && failedOn < rangeTo );

        final int update = jdbcTemplate.update( "UPDATE " + config.getTableName() +
                        " SET range_to=?, status=?, comment=?, lastUpdate=? WHERE range_from=? AND range_to=?", failedOn,
                Config.STATUS_DONE, comment, System.currentTimeMillis(), rangeFrom, rangeTo );
        Assert.isTrue( update == 1 );
        return update;
    }


    public synchronized Long countByStatus( String status ){
        return jdbcTemplate
                .queryForObject( "SELECT COUNT(*) FROM " + config.getTableName() + " Where status=?", Long.class,
                        status );

    }

    public synchronized Long countWorking(){
        return countByStatus( Config.STATUS_WORKING );
    }

    public Long countDone(){
        return countByStatus( Config.STATUS_DONE );
    }

    public Long countError(){
        return countByStatus( Config.STATUS_ERROR );
    }


    public Long sumForStatus( String status ){

        logger.debug( "sumForStatus({})", status );

        String whereClause = "";
        if( status != null ){
            whereClause = " WHERE status='" + status + "'";
        }

        Long result = jdbcTemplate
                .queryForObject( "SELECT SUM(range_to-range_from) FROM " + config.getTableName() + whereClause,
                        Long.class );

        logger.debug( "sumForStatus-{}=", status, result );

        // if result is null, return 0 to avoid returning null.
        if( result == null ){
            result = 0L;
        }

        return result;
    }

    public synchronized Long sumWorking(){
        return sumForStatus( Config.STATUS_WORKING );
    }

    public Long sumDone(){
        return sumForStatus( Config.STATUS_DONE );
    }

    public Long sumError(){
        return sumForStatus( Config.STATUS_ERROR );
    }

    public Long getOldestCreatedTime(){
        return jdbcTemplate.queryForObject( "SELECT MIN (createdTime) FROM " + config.getTableName(), Long.class );
    }

    public Long getLatestUpdateTime(){
        return jdbcTemplate.queryForObject( "SELECT MAX (lastUpdate) FROM " + config.getTableName(), Long.class );
    }


    public synchronized Long countByStatusAndAge( String status, long olderThanSecs ){
        return jdbcTemplate
                .queryForObject( "SELECT COUNT(*) FROM " + config.getTableName() + " Where status=? AND lastUpdate<?",
                        Long.class, status, System.currentTimeMillis() - olderThanSecs * 1000 );
    }


    public synchronized int cleanUnfinishedStatuses(){
        return cleanStatuses( new String[]{ Config.STATUS_WORKING, Config.STATUS_ERROR } );
    }

    public synchronized int cleanStatuses( String[] status ){
        int update = jdbcTemplate.update( " DELETE FROM " + config.getTableName() + " WHERE status IN ( '" +
                StringUtils.arrayToDelimitedString( status, "', '" ) + "' )" );
        logger.info( "{} cleanStatuses [ status:{}, num:{} ]", config.getTableName(), status, update );
        return update;
    }


    public synchronized int cleanWorkingTooLong(){
        int update = jdbcTemplate
                .update( " DELETE FROM " + config.getTableName() + " WHERE status =? AND lastUpdate<?", Config.STATUS_WORKING,
                        System.currentTimeMillis() - config.getMaxWorkingTimeInSec() * 1000 );
        logger.info( "{} deleted", update );
        return update;
    }


    public synchronized void resetAll(){
        logger.warn( "resetAll - clearing entire table!" );
        initializeTable( true, false );
        logger.info( "resetAll - complete" );
    }
}
